#define Id (\x x)
#define T (\x \y x)
#define F (\x \y y)
#define b0 T
#define b1 F
#define Nil F
#define Cons (\a \b \z (z a b))
#define U (\u u u)
#define Y (\f ((\x f (x x)) (\x f (x x))))
#define Reverse (\self \head \tail \acc (tail (self self) (Cons head acc)))









//// 
// Syntax of Lambda calclus:

// <var> := a|b|c|...|z
// <exp> := <var> | (\<var> <exp>) | (<exp> <exp)















////
// Simplest lambda calculus program


















////
// Getting to the truth of the matter


















////
// Eager or Lazy?


















////
// Making tuples out of closures
// (\a \b \z (z a b))

















////
// (\z z a b) (\x \y x)
// ((\x \y x) a b)
// a




// (\z z a b) (\x \y y)
// ((\x \y y) a b)
// b









////
// Lists from Tuples
// (\i (Cons b0 (Cons b1 Nil)))

















////
// List processing
// (L M N)

















////
// The missing piece, recursion


















////
// Putting it all together. 
// Write a program that reverses the input

















////
// Other demos: 
// hilbert
// primes.dec
// Self interpreter (uni344)
